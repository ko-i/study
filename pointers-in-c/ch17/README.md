# 第17章 经典抽象数据类型

---
### 问题

#### 1. 假定你有一个程序，它读取一系列名字，但必须以反序将它们打印出来。哪种ADT更适合完成这个任务？
* 栈。

---
#### 2. 在超级市场的货架上摆放牛奶时，哪种ADT更为合适？你急需要考虑顾客购买牛奶，也需要考虑超级市场新到一批牛奶的情况。
* 队列。

---
#### 3. 在堆栈的传统接口中，pop函数返回他从堆栈中删除的哪一个元素的值。在一个模块中提供两种接口是不是有可能？
* 不行，pop有副作用。

---
#### 4. 如果堆栈模块具有一个empty函数，用于删除堆栈中所有的值，你觉得模块的功能是不是变得明显更为强大？
* 是功能强大，但那这就不是堆栈了。

---
#### 5. 在push函数中，top_element在存储值之前先增值。但在pop函数中，他却在返回栈顶值后再减值。如果这两个次序弄反，会产生什么后果？
* 这种事情见得多了，我只想说懂得都懂，不懂的我也不多解释，毕竟自己知道就好，细细品吧。你们也别来问我怎么了，利益牵扯太大，说了对你我都没好处，当不知道就行了，其余的我只能说这里面水很深，牵扯到很多东西。详细情况你们自己是很难找的，网上大部分已经删除干净了，所以我只能说懂得都懂。

---
#### 6. 如果在一个使用静态数组的堆栈模块中删除所有的断言，会产生什么后果？
* 这种事情见得多了，我只想说懂得都懂，不懂的我也不多解释，毕竟自己知道就好，细细品吧。你们也别来问我怎么了，利益牵扯太大，说了对你我都没好处，当不知道就行了，其余的我只能说这里面水很深，牵扯到很多东西。详细情况你们自己是很难找的，网上大部分已经删除干净了，所以我只能说懂得都懂。

---
#### 7. 在堆栈的链式实现中，为什么destroy_stack函数从堆栈中逐个弹出每个元素。
* 因为懒。

---
#### 8. 链式堆栈实现的pop函数声明了一个局部变量称为first_node。这个变量可不可以省略？
* 不能，省略了最后没法释放。

---
#### 9. 当一个循环数组已满时，front和rear值之间的关系和堆栈为空时一样。但是，慢和空是两种状态。从概念上说，为什么会出现这种情况？
* 这种事情见得多了，我只想说懂得都懂，不懂的我也不多解释，毕竟自己知道就好，细细品吧。你们也别来问我怎么了，利益牵扯太大，说了对你我都没好处，当不知道就行了，其余的我只能说这里面水很深，牵扯到很多东西。详细情况你们自己是很难找的，网上大部分已经删除干净了，所以我只能说懂得都懂。

---
#### 10. 有两种方法可以用于检测一个已满的循环数组：（1）始终保留一个数组元素不使用。（2）另外增加一个变量，记录数组中元素的个数。哪种方法更好一些？
* 那明显是第二种。

---
#### 11. 编写语句，根据front和rear的值计算队列中元素的数量。
``` c
count = (rear + size - front) % size;
```

---
#### 12. 实现队列可以使用单链表，也可以使用双链表，哪个更合适？
* 单链表。

---
#### 13. 画一棵树，它是根据下面的顺序吧这些值依次插入到一颗二叉搜索树中形成的：20，15，18，32，5，91，-4，76，33，41，34，21，90.
* 略。

---
#### 14. 按照升序或降序把一些值插入到一颗二叉搜索树将导致树不平衡。在这样一棵树中查找一个值效率如何？
* O(n)。

---
#### 15. 使用前序遍历，下面这棵树各个节点的访问次序是怎样的？中续遍历呢？后续遍历呢？层次遍历呢？图略。
* 前序遍历：54，36，22，16，25，41，40，51，72，61，80，73。
* 中序遍历：16，22，25，36，40，41，51，54，61，72，73，80。
* 后续遍历：16，25，22，40，51，41，36，61，73，80，72，54。
* 层次遍历：54，36，72，22，41，61，80，16，25，40，51，73。

---
#### 16. 改写do_pre_order_traversal函数，用于执行树的中序遍历。
*代码如下：
``` c
static void do_mid_order_traverse(int current, void (*callback)(TREE_TYPE value))
{
	if(current < ARRAY_SIZE && tree[current] != 0)
	{
		do_mid_order_traverse(left_child(current), callback);
        callback(tree[current]);
		do_mid_order_traverse(right_child(current), callback);
	}
}
```
---
#### 17. 改写do_pre_order_traversal函数，用于执行树的后序遍历。
*代码如下：
``` c
static void do_last_order_traverse(int current, void (*callback)(TREE_TYPE value))
{
	if(current < ARRAY_SIZE && tree[current] != 0)
	{
		do_last_order_traverse(left_child(current), callback);
        callback(tree[current]);
		do_last_order_traverse(right_child(current), callback);
	}
}
```
---
#### 18. 二叉搜索树的那种遍历方法可以以升序依次访问树中所有的节点？那种遍历方法可以以降序依次访问树中的节点？
* 左子树优先中序遍历是升序访问。
* 右子树优先中序遍历是降序访问。

---
#### 19. destroy_tree函数通过释放所有分配给书中节点的内存来删除这棵树，这意味着所有的树节点必须以某个特定的次序来进行处理。那种类型的遍历适合这个任务？
* 后序遍历。

---

### 编程练习

#### 1. 
* /stack/d_stack.c

#### 2. 
* /queue/d_queue.c

#### 3. 
* /queue/l_queue.c

#### 4. 
* /pe17.4/

#### 5. 
* /tree/a_tree.c

#### 6. 
* /tree/a_tree.c

#### 7. 
* /tree/l_tree.c

#### 8. 
* 留给有缘人。

#### 9. 
* /tree/l_tree.c

#### 10. 
* /tree/l_tree.c

#### 11. 
* 留给有缘人。

---