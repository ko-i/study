# 第8章 数组

---
### 问题

#### 1. 根据下面给出的声明和数据，对每个表达式进行求值并写出他们的值。在对每个表达式进行求值时使用原先给出的值（也就是说，某个表达式的结果不影响后面的表达式）。假定ints数组在内存中的起始位置是100，整形值和指针的长度都是4个字节。
``` c
int ints[20] = {10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120, 130, 140, 150, 160, 170, 180, 190, 200};

(Other declarations)

int *ip = ints + 3;
```
* 问题表格连同答案：

| 表达式 | 值 | 表达式 | 值 |
| :--- | :--- | :--- | :--- |
| `ints` | 100 | `ip` | 112 |
| `ints[4]` | 50 | `ip[4]` | 80 |
| `ints + 4` | 116 | `ip + 4` | 128 |
| `*ints + 4` | 14 | `*ip + 4` | 44 |
| `*(ints + 4)` | 50 | `*(ip + 4)` | 80 |
| `ints[-2]` | - | `ip[-2]` | 20 |
| `&ints` | 100 | `&ip` | - |
| `&ints[4]` | 116 | `&ip[4]` | 128 |
| `&ints + 4` | 116 | `&ip + 4` | - |
| `&ints[-2]` | - | `&ip[-2]` | 104 |

---
#### 2. 表达式`array[i + j]`和`i + j[array]`是不是相等？
* 不是。

---
#### 3. 下面的声明试图按照从1开始的下标访问数组data，它能行吗？
``` c
int actual_data[20];
int *data = actual_data - 1;
```
* 不行。

---
#### 4. 下面的循环用于测试某个字符串是否是回文，请对它进行重写，用指针变量代替下标。
``` c
char buffer[SIZE];
int front, rear;
...
front = 0;
rear = strlen(buffer) - 1;
while(front < rear)
{
    if(buffer[front] != buffer[rear])
    {
        break;
    }

    front += 1;
    rear -= 1;
}

if(front >= rear)
{
    printf("It is a palindrome!\n");
}
```
* 修改如下：
``` c
char buffer[SIZE];
int front, rear;
...
front = 0;
rear = strlen(buffer) - 1;
while(front < rear)
{
    if(*(buffer + front) != *(buffer + rear))
    {
        break;
    }

    front += 1;
    rear -= 1;
}

if(front >= rear)
{
    printf("It is a palindrome!\n");
}
```

---
#### 5. 指针在效率上可能强于下标，这是使用它们的动机之一。那么什么时候是用下标是合理的，经管他在效率上可能有所损失？
* 如果指针表示维护的代价远大于其带来的效率提升时。

---
#### 6. 在你的机器上编译函数try1至try5，并分析结果的汇编代码。你的结论是什么？
* 具体的汇编代码见那几个`try*.s`文件，从代码长度可以粗浅的分析出：大致结论与书中相同，但我所使用的编译器似乎已经足够的高效，除了`try5.c`的编译结果可以看出明显好于`try1.c`的编译结果，其它几个和`try1.c`差别不大，甚至均产生了更多的汇编代码。

---
#### 7. 测试你对前一个问题的结论，方法是运行每一个函数并对他们的执行时间进行计时。把数组的元素增加到几千个，增加实验的准确性，因为此时复制所占用的时间远远超过程序不相关部分所占用的时间。同样，在一个循环内部调用函数，让它重复执行足够多的次数，这样你可以精确的为执行时间及时。为这个实验两次编译程序，一次不使用任何优化措施，另一次使用优化措施。如果你的编译器可以提供选择，请选择优化措施以获得最佳速度。
| 文件 | 运行时间（未优化） | 运行时间（最优化）|
| :--- | :--- | :--- |
| try1.c | 0.003111 | 0.000002 |
| try2.c | 0.003182 | 0.002160 |
| try3.c | 0.002980 | 0.002137 |
| try4.c | 0.002951 | 0.002070 |
| try5.c | 0.002793 | 0.001999 |

* 能看出来效率确实有所提升，改变代码的效果提升不明显，使用优化效果提升较明显。
* 而有一个奇怪的位置就是对try1进行优化选项的结果，可能编译器在针对两个数组初始化的默认值相同，然后就没有进行复制操作？

---
#### 8. 下面声明取自某个源文件：
``` c
int a[10];
int *b = a;
```
#### 但在另一个不同的源文件中，却发现了这样的代码：
``` c
extern int *a;
extern int b[];
int x, y;
...
x = a[3];
y = b[3];
```
#### 请解释一下，当两条赋值语句执行时会发生生么？（假定整形和指针的长度都是4个字节。）
* 在第1个赋值中，编译器成为a是一个指针变量，所以它提取存储在那里的指针值，并加上12（3和整形长度相乘），然后对这个结果执行间接访问操作。但a实际上是整形数组的起始位置，所以作为“指针”获得的这个值实际上是数组的第一个整形元素。它与12相加，其结果解释为一个地址，然后对它进行间接访问。作为结果，它或者将提取一些任意内存位置的内容，或者由于某种地址错误而导致程序失败。
* 在第2个赋值中，编译器认为b是个数组名，所以它把12（3的调整结果）加到b的存储地址，然后间接访问操作从那里获得值。事实上，b是个指针变量，所以从内存中提取的后面三个字实际上是从另外的任意变量中取得的。这个问题说明了指针和数组虽然存在关联，但绝不是相同的。

---
#### 9. 编写一个声明，初始化一个名叫`coin_values`的整形数组，各个元素的值分别表示当前各种美元硬币的币值。
*声明如下：
``` c
int coin_values[] = {1, 5, 10, 25, 50, 100};
```

---
#### 10. 给定下列声明
``` c
int array[4][20];
```
#### 请写出下面每个表达式的值。假定数组的起始位置为1000，整型值在内存中占据2个字节的内存空间.
* 表达式与答案如下：

| 表达式 | 值 |
| :--- | :--- |
| `array` | 1000 |
| `array + 2` | 1040 |
| `array[3]` | 1060 |
| `array[2] - 1` | 1020 |
| `&array[1][2]` | 1024 |
| `&array[2][0]` | 1040 |

---
#### 11. 给定下列声明
``` c
int array[4][2][3][6];
```
#### 计算上表中各个表达式的值。同时，写出变量x所需的声明，这样表达式不用进行强制类型转换就可以赋值给x。假定数组的起始位置为1000，整形值在内存中占据4个字节的空间
* 表达式与答案如下：

| 表达式 | 值 | X的类型 |
| :--- | :--- | :--- |
| `array` | 1000 | `int* x[2][3][6]` |
| `array + 2` | 1288 | `int* x[2][3][6]` |
| `array[3]` | 1432 | `int* x[2][3][6]` |
| `array[2] - 1` | 1144 | `int* x[2][3][6]` |
| `array[2][1]` | 1360 | `int* x[3][6]` |
| `array[1][0] + 1` | 1360 | `int* x[3][6]` |
| `array[1][0][2]` | 1408 | `int* x[6]` |
| `array[0][1][0]` | 1072 | `int* x[6]` |
| `array[3][1][2][5]` | 0 | `int x` |
| `&array[3][1][2][5]` | 1572 | `int* x` |

---
#### 12. C的数组按照行主序存储。什么时候需要使用这个信息？
* 当多维数组需要计算某行的首地址时。

---
#### 13. 给定下列声明：
``` c
int array[4][5][3];
```
#### 把下列各个指针表达式转换为下标表达式。
* 指针表达式与下标表达式结果如下：

| 表达式 | 下表表达式 |
| :--- | :--- |
| `*array` | `array[0]` |
| `*(array + 2)` | `array[2][0]` |
| `*(array + 1) + 4` | `array[1][4]` |
| `*(*(array + 1) + 4)` | `array[1][4]` |
| `*(*(*(array + 3) + 1) + 2)` | `array[3][1][2]` |
| `*(*(*array + 1) + 2)` | `array[1][2][0]` |
| `*(**array + 2)` | `array[0][0][2]` |
| `**(*array + 2)` | `array[0][2][0]` |
| `***array` | `array[0][0][0]` |

---
#### 14. 多维数组的各个下标必须单独出现在一对方括号内。在什么条件下，下列这些代码段可以通过编译而不会产生任何警告信息？
``` c
int array[10][20];
...
i = array[3, 4];
```
* 这个当i的声明是int *i[20]的时候，不会产生警告信息。

---
#### 15. 给定下列声明
``` c
unsigned int which;
int array[SIZE];
```
#### 下面两条语句哪条更合理？为什么？
``` c
if(array[which] == 5 && which < SIZE)...
```
``` c
if(which < SIZE && array[which] == 5)...
```
* 第二条更合理，因为提前检查数组是否越界。

---
#### 16. 在下面的代码中，变量`array1`和`array2`有什么区别（如果有的话）？
``` c
void function(int array1[10])
{
    int array2[10];
    ...
}
```
* array1其实是一个int类型的指针变量，array2是一个指向整数数组首地址的一个整数类型的指针常量。

---
#### 17. 解释下面两种const关键字的用法和显著区别所在。
``` c
void function(int const a, int const b[]);
```
* 第一个const表示a是一个整型常量，在此函数中不会改变a的副本的值。
* 第二个const可以防止这个b指针对间接访问的值进行修改。

---
#### 18. 下面的函数原型可以改写为什么形式？但保持结果不变？
``` c
void function(int array[3][2][5]);
```
* 可以改为这样：
``` c
void function(int *array[2][5]);
```

---
#### 19. 在程序8.2的关键字查找例子中，字符指针数组的末尾增加了一个NULL指针，这样我们就不需要知道表的长度。那么，矩阵方案应如何进行修改，使其达到的同样效果呢？写出用于访问修改后的矩阵的for语句。
``` c
#include <string.h>

int lookup_keyword(char const * const desired_word, char const *keyword_table[], int const size)
{
	char const ** kwp;

	// 对于表中的每个单词...
	for(kwp = keyword_table; kwp != NULL; kwp++)
	{
		// 如果这个单词与我们所查找的单词匹配，返回他在表中的位置
		if(strcmp(desired_word, **kwp) == 0)
		{
			return kwp - keyword_table;
		}
	}

	return -1;
}
```

---

### 编程练习

#### 1. 
* pe8.1.c

#### 2. 
* pe8.2.c

#### 3. 
* pe8.3.c

#### 4. 
* pe8.4.c

#### 5. 
* pe8.5.c

#### 6. 
* pe8.6.c

#### 7. 
* pe8.7.c

#### 8. 
* pe8.8.c

---
