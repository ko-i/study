# 第9章 字符串、字符和字节

---
### 问题

#### 1. C语言缺少显式的字符串数据类型，这是一个优点还是一个缺点？
* 这当然是一个优点，因为可以用char数组实现。

---
#### 2. `strlen`函数返回一个无符号量（`size_t`），为什么这里无符号值比有符号值更合适？但返回无符号值其实也有缺点，为什么？
* 因为字符串长度不可能是负值，从而可以表现更大范围的长度，但程序员很容易不注意将其和有符号数混用。

---
#### 3. 如果`strcat`和`strcpy`函数返回一个指向目标字符串末尾的指针，和事实上返回一个指向目标字符串起始位置的指针相比，有没有什么优点？
* 可以判断这个指针是否为`NUL`，从而了解到有没有出现截断行为，也避免越界。

---
#### 4. 如果从数组x复制50个字节到数组y，最简单的方法是什么？
``` c
memcpy(y, x, 50);
```

---
#### 5. 假定你有一个名叫buffer的数组，它的长度为BSIZE个字节，你用下面这条语句把一个字符串复制到这个数组：
``` c
strncpy(buffer, some_other_string, BSIZE - 1);
```
#### 它能不能保证buffer中的内容是一个有效的字符串？
* 如果`some_other_string`的长度比`BSIZE - 1`大，那就不能成功复制到这个数组中。
* 还缺少后续的`buffer[BSIZE - 1] = '\0'`语句。

---
#### 6. 用下面这种方法：
``` c
if(isalpha(ch)){
```
#### 取代下面这种显式的测试有什么优点？
``` c
if(ch >= 'A' && ch <= 'Z' || ch >= 'a' && ch <= 'z'){
```
* 可移植性更好。

---
#### 7. 下面的代码怎样进行简化？
``` c
for(p_str = message; *p_str != '\0'; p_str++)
{
    if(islower(*p_str))
    {
        *p_str = toupper(*p_str);
    }
}
```
* 简化如下：
``` c
for(p_str = message; *p_str != '\0'; p_str++)
{
    *p_str = toupper(*p_str);
}
```

---
#### 8. 下面的表达式有何不同？
``` c
memchr(buffer, 0, SIZE) - buffer
```
``` c
strlen(buffer)
```
* 如果`buffer`的`SIZE`范围中未出现`0`，那`memchr`就尴尬了。

---

### 编程练习

#### 1. 
* pe9.1.c

#### 2. 
* pe9.2.c

#### 3. 
* pe9.3.c

#### 4. 
* pe9.4.c

#### 5. 
* pe9.5.c

#### 6. 
* pe9.6.c

#### 7. 
* pe9.7.c

#### 8. 
* pe9.8.c

#### 9. 
* pe9.9.c

#### 10. 
* pe9.10.c

#### 11. 
* pe9.11.c

#### 12. 13. 14
* pe9.12.c

#### 15. 
* pe9.15.c

#### 16. 
* pe9.16.c

#### 17. 
* 这道题就留给您来写吧。
---

