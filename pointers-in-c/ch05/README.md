# 第5章 操作符和表达式

---
### 问题

#### 1. 下面这个表达式的类型和值分别是什么？
``` c
(float)(25 / 10)
```
* 类型是`float`，值是`2.0`。

---
#### 2. 下面这个程序的结果是什么？
``` c
int func(void)
{
    static int counter = 1;
    
    return ++counter;
}

int main()
{
    int answer;

    answer = func() - func() * func();
    printf("%d\n", answer);
}
```
* -10 (2 - 3 * 4)
* 可能会因为编译器的不同而不同

---
#### 3. 你认为位操作符和移位操作符可以用在什么地方？
* 可以用在内存很小的嵌入式设备上。

---
#### 4. 条件操作符在运行时较之if语句更快还是更慢？试比较下面两个代码段。
#### 代码1
``` c
if(a > 3)
{
    i = b + 1;
}
else
{
    i = c * 5;
}
```
#### 代码2
``` c
i = a > 3 ? b + 1 : c * 5;
```
* 在速度上并无优劣之分，只是视觉上的不同。

---
#### 5. 可以被4整除的年份是闰年，但是其中能被100整除的年份又不是闰年。但是，这其中能够被400整除的年份又是闰年。请用一条赋值语句，如果变量`year`是闰年，把变量`leap_year`设置为真。如果`year`的值不是闰年，把`leap_year`设置为假。
* `leap_year = (year % 400 == 0 || (year % 4 == 0 && year % 100 != 0)) ? 1 : 0;`

---
#### 6. 哪些操作符具有副作用，它们具有什么副作用？
| 具有副作用的操作符 | 副作用 |
| :----: | :----: |
| ++, -- | 会修改相邻操作数的值 |
| = | 会修改左操作符的值 |

---
#### 7. 下面这个代码段的结果是什么？
``` c
int a = 20;
...
if(1 <= a <= 10)
{
    printf("In range\n");
}
else
{
    printf("Out of range\n");
}
```
* 打印结果：
> In range

---
#### 8. 改写下面的代码段，消除多余的代码。
``` c
a = f1(x);
b = f2(x + a);
for(c = f3(a, b); c > 0; c = f3(a, b))
{
    *statements*
    a = f1(++x);
    b = f2(x + a);
}
```
* 改写结果：
``` c
for(c = f3(f1(x), f2(x + a)); c > 0; c = f3(f1(++x), f2(x + a)))
{
    *statements*
}
```

---
#### 9. 下面的循环能够实现它的目的吗？
``` c
non_zero = 0;
for(i = 0; i < ARRAY_SIZE; i += 1)
{
    non_zero += array[i];
}

if(!none_zero)
{
    printf("Values are all zero\n");
}
else
{
    printf("There are nonzero values.\n");
}
```
* 有可能不行，如果数组中存在非0值且最后的总和恰好为0（溢出）那就不行了。

---
#### 10. 根据下面的变量声明和初始化，计算下列每个表达式的值。如果某个表达式具有副作用（也就是说它修改了一个和多个变量的值），注明它们。在计算每个表达式时，每个变量所使用的是开始时给出的初始值，而不是前一个表达式的结果。
``` c
int a = 10, b = -25;
int c = 0, d = 3;
int e = 20;
```
* 表达式连同答案:

| 序号| 表达式 | 值 | 副作用 |
| :---- | :---- | :----: | :---- |
| a | `b` | -25 |  |
| b | `b++` | -25 | b的值变为-24 |
| c | `--a` | 9 | a的值变为9 |
| d | `a / 6` | 1 |  |
| e | `a % 6` | 4 |  |
| f | `b % 10` | -5 |  |
| g | `a << 2` | 40 |  |
| h | `b >> 3` | -4 |  |
| i | `a > b` | 1 |  |
| j | `b = a` | 10 | b的值变为10 |
| k | `b == a` | 0 |  |
| l | `a & b` | 2 |  |
| m | `a ^ b` | -19 |  |
| n | `a \| b` | -17 |  |
| o | `~b` | 24 |  |
| p | `c && a` | 0 |  |
| q | `c \|\| a` | 1 |  |
| r | `b ? a : c` | 10 |  |
| s | `a += 2` | 12 | a的值变为12 |
| t | `b &= 20` | 4 | b的值变为4 |
| u | `b >>= 3` | -4 | b的值变为-4 |
| v | `a %= 6` | 4 | a的值变为4 |
| w | `d = a > b` | 1 | d的值变为1 |
| x | `a = b = c = d` | 3 | a, b, c的值都变为3 |
| y | `e = d + (c = a + b) + c` | -27 | c的值变为-15，e的值变为-27 |
| z | `a + b * 3` | -65 |  |
| aa | `b >> a - 4` | -1 | 备注：`>>`优先级要比`-`低 |
| bb | `a != b != c` | 1 |  |
| cc | `a == b == c` | 1 |  |
| dd | `d < a < e` | 1 |  |
| ee | `e > a > d` | 0 |  |
| ff | `a - 10 > b + 10` | 1 |  |
| gg | `a & 0x1 == b & 0x1` | 0 | 备注：`==`的优先级要比`&`高 |
| hh | `a \| b << a & b` | -25590 |  |
| ii | `a > c \|\| ++a > b` | 1 | a的值变为11 |
| jj | `a > c && ++a > b` | 1 | a的值变为11 |
| kk | `! ~ b++` | 0 | b的值变为-24 |
| ll | `b++ & a <= 30` | 1 | b的值变为-24 |
| mm | `a - b, c += d, e - c` | 17 | c的值变为3 |
| nn | `a <<= 3 > 0` | 20 | a的值变为20 |
| oo | `a <<= d > 20 ? b && c++ : d--` | 80 | a的值变为80，d的值变为1 |
* 测试代码：
``` c
# include <stdio.h>

int main(int argc, char const *argv[])
{
	int a = 10, b = -25;
	int c = 0, d = 3;
	int e = 20;

	printf("%d\n", b); // change the expression here

	printf("a = %d\n", a);
	printf("b = %d\n", b);
	printf("c = %d\n", c);
	printf("d = %d\n", d);
	printf("e = %d\n", e);

	return 0;
}
```

---
#### 11. 下面列出了几个表达式。请判断编译器是如何对各个表达式进行求值的，并在不改变求值顺序的情况下，尽可能去去除多余的括号。
* 题目连同答案如下：

| 序号 | 表达式 | 求值顺序 | 改变后的表达式 |
| :---- | :---- | :---- | :---- |
| a | `a + (b / c)` | `b / c`, `+ a` | `a + b / c` |
| b | `(a + b ) / c` | `a + b`, `/ c` | `(a + b ) / c` |
| c | `(a * b) % 6` | `a * b`, `% 6` | `a * b % 6` |
| d | `a * (b % 6)` | `b % 6`,  `a *`| `a * (b % 6)` |
| e | `(a + b) == 6` | `a + b`, `== 6` | `a + b == 6` |
| f | `!((a >= '0') && (a <= '9'))` | `a >= '0'`, `a <= '9'`, ` && `, `!` | `!(a >= '0' && a <= '9')` |
| g | `((a & 0x2f) == (b \| 1)) && ((~c) > 0)` | `a & 0x2f`, `b \| 1`, `==`, `~c`, `> 0`, `&&` | `(a & 0x2f) == (b \| 1) && ~c > 0` |
| h | `((a << b) - 3) < (b << (a + 3))` | `a << b`, `- 3`, `a + 3`, `b <<`, `<` | `(a << b) - 3 < b << a + 3` |
| i | `~(a++)` | `a++`, `~` | `~a++` |
| j | `((a == 2) \|\| (a == 4)) && ((b == 2) \|\| (b == 4))` | `a == 2`, `a == 4`, 第一个`\|\|`, `b == 2`, `(b == 4`, 第二个`\|\|`, `&&`) | `(a == 2 \|\| a == 4) && (b == 2 \|\| b == 4)` |
| k | `(a & b) ^ (a \| b)` | `a & b`, `a \| b`, `^` | `a & b ^ (a \| b)` |
| l | `(a + (b + c))` | `b + c`, `a +` | `a + (b + c)` |

---
#### 12. 如何判断在你的机器上对一个有符号值进行右移位操作时执行的是算术移位还是逻辑移位？
* 用一个负值测试，如果右移一位后符号未发生改变（还是负值），则为算数移位，否则（变为正值）为逻辑移位。

---
### 编程练习

#### 1. 
* pe5.1.c

#### 2. 
* pe5.2.c

#### 3. 
* pe5.3.c

#### 4. 
* pe5.4.c

#### 5. 
* pe5.5.c

---