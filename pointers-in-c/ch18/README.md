# 第18章 运行时环境

---
### 问题

#### 1. 在你的环境中，堆栈帧的样子是什么样的？
* 如code18.1.s中表示，是有rsp和rbp控制的，rsp作为栈帧开辟栈空间，rbp作为基址寄存器内存放返回地址，并使用偏移量进行局部变量访问。
* 有个有趣的地方在于不同于传统的编译器，我所使用的编译器会在发现本函数没有子函数调用时不存在使用rsp开辟栈空间的行为。

---
#### 2. 在你的系统中，有意义的外部标识符最长可以有多少个字符？
* 如p18.2.s中所示，我的系统好像没有限制。

---
#### 3. 在你的环境中，寄存器可以存储多少个变量？对于指针和非指针值，他是不是进行了任何区分？
* 如code18.1.s中所示，我所使用的编译器自动忽视我所标注的register变量。
* 针对指针的赋值是先将代表指针所指向的值（立即数）存入ecx寄存器中，再将ecx寄存器的值存入栈中。

---
#### 4. 在你的环境中，参数是如何传递给函数的？值是如何从函数返回的？
* 通过将参数先暂存在寄存器当中，然后在新函数的ebp压栈后再复制过来。
* 通过rax寄存器存储返回值。

---
#### 5. 在本章我们所使用的这台机器上，如果一个函数把它的一个或多个参数声明为寄存器变量，那么这个函数的参数在函数序中和平常一样被压入到堆栈中，然后在复制到正确的寄存器中。如果这些参数能够直接保存到寄存器中，函数的效率会更高一些。这种参数传递的技巧能够实现吗？如果能，怎么实现呢？
* 通过答案我们可以知道：调用函数无法知道被调函数中哪些参数是寄存器变量，所以不能实现。

---
#### 6. 在我们所讨论的环境中，调用函数负责清除它压入到堆栈的参数。那么能不能由被调用函数来完成这项任务呢？如果不能，那么在满足什么条件下它才可能呢？
* 不能，因为它只管接受它的，他哪里知道实际上传了多少。
* 在调用函数告诉他向他传了多少参数时。

---
#### 7. 如果说汇编语言程序比C程序效率高，那么为什么不用汇编语言来编写所有程序呢？
* 机器语言比汇编效率还高呢，您怎么不直接用机器语言编程。

---

### 编程练习

#### 1. 
* pe18.1.c pe18.1.s

#### 2. 
* pe18.2.c pe18.2.s

#### 3. 
* 留给有缘人。

---
