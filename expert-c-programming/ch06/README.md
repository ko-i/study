# 第6章 运动的诗章：运行时数据结构

---
### 编程挑战：

---
#### 编译`hello world`程序，在可执行文件中你那个执行`ls -l`，得到文件的总体大小。运行`size`得到文件里各个段的大小
* hello world测试代码如下：
``` c
#include <stdio.h>

int main(int argc, char const *argv[])
{
	printf("Hello World!\n");

	return 0;
}
```
* 使用`ls -l a.out`：  
> -rwxr-xr-x  1 akson  staff  49424 Dec 26 17:00 a.out  
* 使用`size a.out`： 

| __TEXT | __DATA | __OBJC | others | dec | hex |
| ---: | ---: | ---: | ---: | ---: | ---: |  
| 16384	| 16384 | 0	| 4295000064 | 4295032832 |	100010000 | 

---
#### 增加一个全局的`int[1000]`数组声明，重新进行编译，再用上面的命令得到总体及各个段的大小，注意前后的区别。
* 修改后代码：
``` c
#include <stdio.h>

int my_array[1000];

int main(int argc, char const *argv[])
{
	printf("Hello World!\n");

	return 0;
}
```
* 使用`ls -l a.out`：  
> -rwxr-xr-x  1 akson  staff  49464 Dec 26 17:12 a.out  
* 使用`size a.out`：  

| __TEXT | __DATA | __OBJC | others | dec | hex |
| ---: | ---: | ---: | ---: | ---: | ---: |  
| 16384	| 16384 | 0	| 4295000064 | 4295032832 |	100010000 |
* 文件了`size`增加了`40`个字节，但`DATA`段并没有变化。
* 当我将数组大小改为`10000`时发现`DATA`段变成了`49152`说明存在最小的分配容量，结果如下：

| __TEXT | __DATA | __OBJC | others | dec | hex |
| ---: | ---: | ---: | ---: | ---: | ---: |  
| 16384	| *49152* | 0 | 4295000064 | *4295065600* | *100018000* |

---
#### 现在，在数组的声明中增加初始值（记住，C语言并不强迫对数组进行初始化时为每个元素提供初始值），这将是数组从BSS段转到数据段。重复上面的测量，注意各个段前后大小的区别。
* 上面用的都是全局变量，现在首先将`my_array`移入到`main`内部并且不初始化，代码如下：
``` c
#include <stdio.h>

int main(int argc, char const *argv[])
{
	int my_array[10000];
	printf("Hello World!\n");

	return 0;
}
```
* 结果显示如下：

| __TEXT | __DATA | __OBJC | others | dec | hex |
| ---: | ---: | ---: | ---: | ---: | ---: |  
| 16384	| 16384 | 0	| 4295000064 | 4295032832 |	100010000 |
* 然后给值初始化，代码如下：
``` c
#include <stdio.h>

int main(int argc, char const *argv[])
{
	int my_array[1000] = {0};
	printf("Hello World!\n");

	return 0;
}
```
* 结果如下：

| __TEXT | __DATA | __OBJC | others | dec | hex |
| ---: | ---: | ---: | ---: | ---: | ---: |  
| 16384	| 16384 | 0	| 4295000064 | 4295032832 |	100010000 |
* 可以看出并没有什么改变。即使换用了`10000`大小，也依旧没有变化。

---
#### 现在，在函数内声明一个巨大的数组。然后在声明一个巨大的局部数组，但这次加上初始值。重复上面的测量。定义与函数内部的局部数组存储在可执行文件中吗？有没有初始化有什么不同？
* 巨大的数组参见上述`10000`大小的规模，发现如果是全局存储区，会影响DATA段的大小，但局部变量不管初始化与否，对DATA段都没有影响。可以得出静态变量会影响DATA段而局部变量不会。

---
#### 如果在调试状态下编译，文件和段的大小有没有变化？是为了最大限度的优化吗？
* 额啊。

---




